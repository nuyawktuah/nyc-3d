<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8" />
		<title>My first three.js app</title>
		<style>
			html,
			body {
				margin: 0;
				height: 100%;
			}
			canvas {
				width: 100%;
				height: 100%;
				display: block;
			}
		</style>
	</head>
	<body>
		<script src="js/three.js"></script>
		<script src="js/orbitControls.js"></script>
		<script src="js/stats.js"></script>
		<script>
			// Scene
			var scene = new THREE.Scene();
			scene.fog = new THREE.Fog(0xf5f5f5, 1, 10000000);

			// Renderer
			var renderer = new THREE.WebGLRenderer();
			renderer.setSize(window.innerWidth, window.innerHeight);
			renderer.setClearColor(scene.fog.color, 1);
			document.body.appendChild(renderer.domElement);

			// Camera
			const cameraRadius = 60000;
			const theta = 45;
			const phi = 60;
			var camera = new THREE.PerspectiveCamera(
				40,
				window.innerWidth / window.innerHeight,
				2,
				400000
			);
			camera.position.x =
				cameraRadius *
				Math.sin((theta * Math.PI) / 360) *
				Math.cos((phi * Math.PI) / 360);
			camera.position.y = cameraRadius * Math.sin((phi * Math.PI) / 360);
			camera.position.z =
				cameraRadius *
				Math.cos((theta * Math.PI) / 360) *
				Math.cos((phi * Math.PI) / 360);

			// Controls
			var controls = new THREE.OrbitControls(camera);
			// TODO: https://github.com/mrdoob/three.js/issues/7384#issuecomment-149972582

			// Lights
			var directionalLight = new THREE.DirectionalLight(0xaaaaaa, 1);
			directionalLight.position.x = 10000;
			directionalLight.position.y = 10000;
			directionalLight.position.z = 10000;

			var directionalLight2 = new THREE.DirectionalLight(0xaaaaaa, 0.5);
			directionalLight2.position.x = -10000;
			directionalLight2.position.y = 10000;
			directionalLight2.position.z = 0;

			var directionalLight3 = new THREE.DirectionalLight(0xaaaaaa, 0.5);
			directionalLight3.position.x = 10000;
			directionalLight3.position.y = 10000;
			directionalLight3.position.z = -10000;

			scene.add(directionalLight);
			scene.add(directionalLight2);
			scene.add(directionalLight3);

			// Stats
			var stats = new Stats();
			stats.showPanel(0); // 0: fps
			document.body.appendChild(stats.dom);

			animate();

			for (var i = 0; i <= 19; i++) {
				renderBuffers(i);
			}

			async function renderBuffers(index) {
				const verticesBuffer = await fetchBuffer(`vertices${index}.buffer`);
				const vertices = new Float32Array(verticesBuffer);
				delete verticesBuffer;
				const facesBuffer = await fetchBuffer(`faces${index}.buffer`);
				const faces = new Uint32Array(facesBuffer);
				delete facesBuffer;

				const buildingsGeom = new THREE.BufferGeometry();
				buildingsGeom.addAttribute(
					"position",
					new THREE.BufferAttribute(vertices, 3)
				);
				buildingsGeom.setIndex(new THREE.BufferAttribute(faces, 3));
				delete vertices;
				delete faces;

				const buildingsMaterial = new THREE.MeshPhongMaterial({
					color: 0xffffff,
					side: THREE.DoubleSide,
					flatShading: true
				});
				const buildingsMesh = new THREE.Mesh(buildingsGeom.toNonIndexed(), buildingsMaterial);
				scene.add(buildingsMesh);
			}

			function fetchBuffer(file) {
				return fetch(`./buffers/${file}`).then(res => res.arrayBuffer());
			}

			function animate() {
				requestAnimationFrame(animate);
				stats.begin();
				if (resizeRendererToDisplaySize(renderer)) {
					const canvas = renderer.domElement;
					camera.aspect = canvas.clientWidth / canvas.clientHeight;
					camera.updateProjectionMatrix();
				}
				controls.update();
				renderer.render(scene, camera);
				stats.end();
			}

			function resizeRendererToDisplaySize(renderer) {
				const canvas = renderer.domElement;
				const pixelRatio = window.devicePixelRatio;
				const width = canvas.clientWidth * pixelRatio;
				const height = canvas.clientHeight * pixelRatio;
				const needResize = canvas.width !== width || canvas.height !== height;
				if (needResize) {
					renderer.setSize(width, height, false);
				}
				return needResize;
			}
		</script>
	</body>
</html>
